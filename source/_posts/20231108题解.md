---
title: 20231108题解
date: 2023-11-08 16:23:27
updateDate: 2023-11-08 16:23:27
tags:
categories:
- 信奥
- 题解
comments: true
top: 2
---

---
<!--more-->

## eattt

高妙结论题。考场最多就 20 pts。

如果 $a_{i+1}$ 被 $a_i$ 吃，我们就在 $i$ 与 $i+1$ 之间连一条边。容易发现，最终的局面一定是几段不交的链。

考虑统计每一条鱼的贡献。一条鱼吃到最后要么是 $a_i$ 要么是 $-a_i$。我们尝试统计 $a_i$ 和 $-a_i$ 分别出现的次数。

对于 $a_i$ 之前连续的边有几条进行分类讨论：

- 0 条，此时 $a_i$ 压根就没有被吃。贡献为 $a_i\prod_{i=n-k-2}^{n-2}i$。
- 1 条，此时 $a_i$ 被吃了一次。贡献为 $-a_ik\prod_{i=n-k-1}^{n-2}i$。乘 $k$ 是因为 $a_i$ 中被吃的那一次可以是任何一次。
- 2 条，此时有两种可能：$a_{i-1}$ 先被吃，然后 $a_i$ 再被吃；$a_i$ 先被吃，然后 $a_{i-1}$ 再被吃。贡献一正一负。显然 $a_i$ 和 $a_{i-1}$ 的地位相等，所以两种情况的出现次数也一定相同，总贡献就是 0。
- $k$ 条（$k>2$），容易发现 $a_i$ 的正负与 $a_{i-1}$ 的正负可能相同，也可能相反，但是两种可能仍然是次数相同。既然 $a_{i-1}$ 贡献是 0，$a_i$ 贡献也是 0。对 $k$ 归纳即可。

所以大于 1 条边的链是无意义的。我们只要讨论前两种就好了。注意对于第一条和第二条鱼特判。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T>
void read(T &r) {
    r = 0; int ch = getchar(), f = 0;
    while (!isdigit(ch)) { if (ch == 45) f ^= 1; ch = getchar(); }
    while (isdigit(ch)) (r *= 10) += ch - 48, ch = getchar();
    if (f) r = -r;
}

const int maxn = 1e6 + 5;
const long long mod = 1e9 + 7;
int n, k, a[maxn];
long long p[maxn], ans;

long long quick_pow(long long x, long long p) {
    long long res = 1; while (p) {
        if (p & 1LL) (res *= x) %= mod;
        (x *= x) %= mod, p >>= 1;
    } return res;
}

int main() {
    freopen("eattt.in", "r", stdin), freopen("eattt.out", "w", stdout);
    read(n); read(k);
    for (int i = 1; i <= n; i++) read(a[i]);
    p[0] = 1;
    for (int i = 1; i <= n; i++) {
        p[i] = (p[i - 1] * i) % mod;
    }
    for (int i = 1; i <= n; i++) {
        if (i == 1) (ans += a[i] * p[n - 1] % mod * quick_pow(p[n - k - 1], mod - 2)) %= mod;
        else if (i == 2) {
            if (k < n - 1) (ans += a[i] * p[n - 2] % mod * quick_pow(p[n - k - 2], mod - 2)) %= mod;
            (ans += (mod - a[i]) * p[n - 2] % mod * quick_pow(p[n - k - 1], mod - 2) % mod * k) %= mod;
        } else {
            if (k < n - 1) {
                (ans += a[i] * p[n - 2] % mod * quick_pow(p[n - k - 2], mod - 2)) %= mod;
                (ans += (mod - a[i]) * p[n - 3] % mod * quick_pow(p[n - k - 2], mod - 2) % mod * k) %= mod;
            }
        }
    }
    printf("%lld\n", ans * quick_pow(p[n - 1] * quick_pow(p[n - k - 1], mod - 2) % mod, mod - 2) % mod);
    return 0;
}
```

## gcd

形式化来说，我们要求 $\sum_{i=l}^{r}{[\operatorname{gcd}(a_i, G)=1]}$，支持区间修改。

后面那个东西很眼熟啊，考虑莫反：

$$
\begin{aligned}
    &\sum_{i=l}^{r}{[\operatorname{gcd}(a_i, G)=1]} \\
    =&\sum_{i=l}^{r}{\sum_{d \mid \operatorname{gcd}(a_i, G)}{\mu(d)}} \\
    =&\sum_{d \mid G} \mu(d) \sum_{i = l}^{r}{[d \mid a_i]}   
\end{aligned}
$$

前面一个求和是 $\mathcal{O}(\sqrt{G})$ 的。后面一段是区间为 $d$ 的倍数的个数。（想一想 $\mu$ 的定义，其实和容斥是一个道理）。所以我们要在一个可接受的复杂度内求出区间为 $d$ 的倍数的个数，还要支持修改。

由于值域很小，容易想到对于值域内的每一个数都记录它的倍数在哪里出现过，空间复杂度 $\mathcal{O}(W \sqrt{W})$。如果用 `vector` 加二分实现，无法快速处理修改。考虑用平衡树维护。这样询问复杂度是 $\mathcal{O}(\sqrt{G}\log n)$，修改时要把 $a_i$ 的所有因数对应的平衡树也修改，复杂度是 $\mathcal{O}(\sqrt{a_i}\log n)$。

这个东西好像单点修和无修的复杂度是相同的。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T> 
void read(T &r) {
    r = 0; int ch = getchar(), f = 0;
    while (!isdigit(ch)) { if (ch == 45) f ^= 1; ch = getchar(); }
    while (isdigit(ch)) (r *= 10) += ch - 48, ch = getchar();
    if (f) r = -r;
}

const int maxn = 1e5 + 5;
int n, m, a[maxn], f[maxn];
bool np[maxn];
vector<int> primes;
mt19937 rd(time(NULL));
struct node; typedef node* pos;
struct node { int siz, val, key; pos ls, rs; node() { ls = rs = this; }}
buf[maxn * 50], *buf_pos = buf;
pos new_node(int val) { pos p = ++buf_pos; p -> ls = p -> rs = buf; p -> siz = 1, p -> key = rd(), p -> val = val; return p; }
void push_up(pos p) { p -> siz = p -> ls -> siz + p -> rs -> siz + 1; }
void split(pos p, int v, pos &pl, pos &pr) { return p == buf ? void(pl = pr = buf) : (p -> val <= v ? (pl = p, split(p -> rs, v, p -> rs, pr), push_up(p)) : (pr = p, split(p -> ls, v, pl, p -> ls), push_up(p))); }
pos merge(pos pl, pos pr) { return (pl == buf || pr == buf) ? (pl + (pr - buf)) : (pl -> key > pr -> key ? (pl -> rs = merge(pl -> rs, pr), push_up(pl), pl) : (pr -> ls = merge(pl, pr -> ls), push_up(pr), pr)); }
pos root[maxn], ls, rs, xs;

int main() {
    f[1] = 1; np[1] = true;
    for (int i = 2; i <= 1e5; i++) {
        if (!np[i]) {
            f[i] = -1;
            primes.emplace_back(i);
        }
        for (int j : primes) {
            if (i * j > 1e5) break;
            np[i * j] = true;
            f[i * j] = -f[i];
            if (i % j == 0) {
                f[i * j] = 0;
                break;
            }
        }
    }
    read(n);
    for (int i = 1; i <= 1e5; i++) root[i] = buf;
    for (int i = 1; i <= n; i++) {
        read(a[i]);
        for (int d = 1; d * d <= a[i]; d++) {
            if (a[i] % d == 0) {
                root[d] = merge(root[d], new_node(i));
                if (d * d != a[i]) root[a[i] / d] = merge(root[a[i] / d], new_node(i));
            }
        }
    }
    read(m);
    while (m--) {
        int op; read(op);
        if (op == 1) {
            int x, y; read(x); read(y);
            for (int d = 1; d * d <= a[x]; d++) {
                if (a[x] % d == 0) {
                    split(root[d], x - 1, ls, rs);
                    split(rs, x, xs, rs);
                    root[d] = merge(ls, rs);
                    if (d * d != a[x]) {
                        split(root[a[x] / d], x - 1, ls, rs);
                        split(rs, x, xs, rs);
                        root[a[x] / d] = merge(ls, rs);
                    }
                }
            }
            a[x] = y;
            for (int d = 1; d * d <= a[x]; d++) {
                if (a[x] % d == 0) {
                    split(root[d], x, ls, rs);
                    root[d] = merge(merge(ls, new_node(x)), rs);
                    if (d * d != a[x]) {
                        split(root[a[x] / d], x, ls, rs);
                        root[a[x] / d] = merge(merge(ls, new_node(x)), rs);
                    }
                }
            }
        } else {
            int l, r, x; read(l); read(r); read(x);
            int ans = 0;
            for (int d = 1; d * d <= x; d++) {
                if (x % d == 0) {
                    if (f[d] != 0) {
                        split(root[d], l - 1, ls, rs);
                        split(rs, r, xs, rs);
                        ans += f[d] * xs -> siz;
                        root[d] = merge(ls, merge(xs, rs));
                    }
                    if (d * d != x && f[x / d] != 0) {
                        split(root[x / d], l - 1, ls, rs);
                        split(rs, r, xs, rs);
                        ans += f[x / d] * xs -> siz;
                        root[x / d] = merge(ls, merge(xs, rs));
                    }
                }
            }
            printf("%d\n", ans);
        }
    }
    return 0;
}
```