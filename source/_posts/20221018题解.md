---
title: 20221018题解
comments: true
top: 2
date: 2022-10-19 10:06:43
updateDate: 2022-10-19 10:06:43
tags:
categories:
---

---

<!--more-->

## T1 road

### 思路分析

首先可以观察边权的表达式： $c + \lfloor\frac{d}{t + 1}\rfloor$ 。

由于题目说了可以等待，我们可以发现如果等待 1 秒带来的收益（即 $\lfloor\frac{d}{t + 1}\rfloor$ 的减少量）大于 1 ，那么一定要等；如果获得 1 的收益需要等待不止 1 秒，那么一定不需要等。尝试去掉下取整，用数学语言描述两个条件分别如下：

$$
\begin{gather*}
\frac{d}{t + 1} - \frac{d}{t + 2} > 1 \\
\frac{d}{t + 1} - \frac{d}{t + 2} < 1
\end{gather*}
$$

解得两个不等式的解如下：

$$
\begin{gather*}
t < \frac{\sqrt{4d + 1} - 3}{2} \\
t > \frac{\sqrt{4d + 1} - 3}{2}
\end{gather*}
$$

当第一条成立的时候，立即就走，否则等到时刻 $\lfloor\frac{\sqrt{4d + 1} - 3}{2}\rfloor + 1$ 再走。这样比标程常数小的多（标程尝试了 4 种边权）。

当然，你如果不放心，直接在 $\sqrt{d}$ 附近多试几个数就好了。

剩下的就是堆优化 $Dijkstra$ 。

### AC 代码

{% spoiler code %}
```cpp
#include <bits/stdc++.h>
using namespace std;

#define NAME "road"

const int maxn = 1e5 + 5;

struct edge {
    int v;
    long long c, d;
    edge(int _v, long long _c, long long _d) { v = _v, c = _c, d = _d; }
};

vector<edge> graph[maxn];
int n, m;
bool vis[maxn];
priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > pq;

int main() {
    freopen(NAME ".in", "r", stdin);
    freopen(NAME ".out", "w", stdout);
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; i++) {
        static int u, v;
        static long long c, d;
        scanf("%d %d %lld %lld", &u, &v, &c, &d);
        graph[u].emplace_back(v, c, d);
        graph[v].emplace_back(u, c, d);
    }
    pq.emplace(0LL, 1);
    while (!pq.empty()) {
        pair<long long, int> now = pq.top();
        pq.pop();
        if (vis[now.second]) continue;
        vis[now.second] = true;
        if (now.second == n) {
            printf("%lld\n", now.first);
            return 0;
        }
        for (edge e : graph[now.second]) {
            if (vis[e.v]) continue;
            long long sqt = sqrt((e.d << 2) + 1);
            if (now.first > (sqt - 3) >> 1) pq.emplace(now.first + e.c + e.d / (now.first + 1), e.v);
            else {
                // pq.emplace(((sqt - 3) >> 1) + e.c + e.d / (((sqt - 3) >> 1) + 1), e.v);
                pq.emplace((((sqt - 3) >> 1) + 1) + e.c + e.d / (((sqt - 3) >> 1) + 2), e.v);
            }
        }
    }
    printf("-1\n");
    return 0;
}
```
{% endspoiler %}
