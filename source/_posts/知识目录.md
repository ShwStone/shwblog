---
title: 知识目录
date: 2022-07-13 16:21:06
updateDate: 2022-07-13 16:21:06
tags:
categories:
- 信奥
comments: true
top: 10086
---

内容多的会给外链。否则直接写掉。~~（外链可能是咕咕咕）~~

<!-- more -->

## 文件操作
```cpp
freopen("*.in", "r", stdin);
freopen("*.out", "w", stdout);
```

## 模拟 & 贪心 & 递推、递归

仔细读题，注意细节，注意 `long long` 。

[常见模拟及贪心](/2022/10/24/常见模拟)

## 排序
```cpp
bool compare(your_own_node a, your_own_node b) {
    return a.v < b.v;
}
sort(* + 1, * + len + 1, compare);
//不加compare默认从小到大

bool operator < (your_own_node a, your_own_node b) {
    return a.v < b.v;
}
//重载运算符也可以用于sort，但是不能重载int这样的系统数据结构。
```

### [快速排序](/2022/07/13/快速排序)

### 归并排序 & 逆序对

```cpp
int a[maxn], b[maxn];
long long sum; /*****long long is important!*****/

void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    for (int i = l; i <= r; i++) b[i] = a[i];
    int i = l, j = mid + 1;
    for (int k = l; k <= r; k++) {
        if (j > r || (i <= mid && b[i] <= b[j])) a[k] = b[i++]; /*****<= is important*****/
        else a[k] = b[j++], sum += mid - i + 1;
    }
}
```

## 二分 & 三分

```cpp
//二分
int l, r, mid;
while (l < r) {
    mid = (l + r /* + 1*/) >> 1; //手推一下 l + 1 == r 的情况，考虑是否加一
    if (check(mid)) r = mid;
    else l = mid + 1;
}

//精度二分
double l, r, mid, eps;
while (l + eps < r) {
    mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid + eps;
}

//三分求f最小值（最大值改一改）
//最优的三分不是均匀分成3块，而是在mid左右两侧取值，这样显然更快。
int l, r, mid;
while (r - l >= 3) {
    mid = (l + r) >> 1;
    if (f(mid) > f(mid + 1)) l = mid + 1;
    else r = mid;
}
//为了避免边界错误，分到只剩3个数就枚举一遍。
int ans, tmp = INT_MAX;
for (int i = l; i <= r; i++) {
    if (f(i) < tmp) {
        ans = i;
        tmp = f(i);
    }
}
```
## 搜索

### 暴力枚举

### DFS

注意边界，注意 `bool` 数组的标记， 不要重复搜索。

### BFS

注意边界，注意 `bool` 数组的标记， 不要重复搜索。

### 记忆化搜索

### [A*](https://oi-wiki.org//search/astar/) & [IDA*](https://oi-wiki.org//search/idastar/)

#### 记忆化

## [前缀和及二维前缀和](/2022/07/13/Prozor-题解)

```cpp
for (int i = 1; i <= n; i++) {
    sum[i] = sum[i - 1] + num[i];
}
//查找区间和：i...j = sum[j] - sum[i - 1];

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + num[i][j];
    }
}
//查找矩阵和：(x,y),(i,j) = sum[i][j] - sum[i][y - 1] - sum[x][j - 1] + sum[x - 1][y - 1];
```

## 差分
```cpp
for (int i = 1; i <= n; i++) {
    f[i] = num[i] - num[i - 1];
}
//区间更改：i...j + d -> f[i] += d; f[j + 1] -= d;
```

## 尺取法
拿草稿纸画一画。

## 数据结构
### 单调栈（含悬线法）

悬线法我不会啊。

单调栈一般维护当前节点往前找到的第一个小于/大于它的点，分别对应递增栈/递减栈。

```cpp
//递增栈
stack<int> s;
for (int i = 1; i <= n; i++) {
    while (!s.empty() && num[s.top()] >= num[i]) s.pop();
    min_left[i] = s.top();
    s.push(i);
}
//min_left中存储向左第一个小于它的节点的下标。
```

### 单调队列

单调队列一般维护当前节点往前找m个点的最大/小值，分别对应递增队列/递减队列。一般用 `deque` 实现。

```cpp
//递增队列
while (!q.empty()) q.pop_back();
num[0] = num[n + 1] = inf;
q.push_back(0);
for (int i = 1; i < k; i++) {
    while (!q.empty() && num[q.back()] >= num[i]) q.pop_back();
    q.push_back(i);
}
for (int i = k; i <= n; i++) {
    while (!q.empty() && num[q.back()] >= num[i]) q.pop_back();
    q.push_back(i);
    while (!q.empty() && q.front() < i - k + 1) q.pop_front();
    minium[i - k + 1] = num[q.front()];
}
```

### 优先队列（堆）

```cpp
bool operator < (your_own_node a, your_own_node b) {
    return a.v < b.v;
}
//重载运算符不能重载int这样的系统数据结构。

priority_queue<your_own_node> p_q;
//注意优先队列与运算符重载相反，这样写是大根堆。

template<class T>
class compare {
public:
    bool operator () (T a, T b) {
        return abs(a) < abs(b);
    }
};
priority_queue<int, vector<int>, compare<int> > p_q;
//用仿函数就可以支持系统类型，不过仍然相反，这样写是按绝对值的大根堆。
//less和greater其实也是这个原理。
```

## [数据结构](/2022/07/13/欢迎)

## 动态规划

### 线性动规

### [背包](/2022/07/13/弹珠-题解)

### 区间动规

### 树型动规

## 图论

### 图的存储

### 拓扑排序

### 最短路算法

### 最小生成树算法

## STL

### pair

### map

### set

### bitset

### stack

### queue

### deque

### priority_queue

### vector
