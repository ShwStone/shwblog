---
title: 知识目录
date: 2022-07-13 16:21:06
updateDate: 2022-07-13 16:21:06
tags:
categories:
- 信奥
comments: true
top: 10086
---

外链说明：

一下子讲不清楚的会给外链，但可能我并没有写这方面的内容。对我来说很重要的知识点会指向一篇空文章，我会尽快把它们写完，其他的会指向 [oi-wiki](https://oi-wiki.org/) ，但以后也会一一补上。

<!-- more -->

## 文件操作
```cpp
freopen("*.in", "r", stdin);
freopen("*.out", "w", stdout);
```

## 模拟 & 贪心 & 递推、递归

仔细读题，注意细节，注意 `long long` 。

[常见模拟及贪心](/2022/10/24/常见模拟)

## 排序
```cpp
bool compare(your_own_node a, your_own_node b) {
    return a.v < b.v;
}
sort(* + 1, * + len + 1, compare);
//不加compare默认从小到大

bool operator < (your_own_node a, your_own_node b) {
    return a.v < b.v;
}
//重载运算符也可以用于sort，但是不能重载int这样的系统数据结构。
```

### [快速排序](/2022/07/13/快速排序)

### 归并排序 & 逆序对

```cpp
int a[maxn], b[maxn];
long long sum; /*****long long is important!*****/

void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    for (int i = l; i <= r; i++) b[i] = a[i];
    int i = l, j = mid + 1;
    for (int k = l; k <= r; k++) {
        if (j > r || (i <= mid && b[i] <= b[j])) a[k] = b[i++]; /*****<= is important*****/
        else a[k] = b[j++], sum += mid - i + 1;
    }
}
```

## 二分 & 三分

```cpp
//二分
int l, r, mid;
while (l < r) {
    mid = (l + r /* + 1*/) >> 1; //手推一下 l + 1 == r 的情况，考虑是否加一
    if (check(mid)) r = mid;
    else l = mid + 1;
}

//精度二分
double l, r, mid, eps;
while (l + eps < r) {
    mid = (l + r) / 2;
    if (check(mid)) r = mid;
    else l = mid + eps;
}

//三分求f最小值（最大值改一改）
//最优的三分不是均匀分成3块，而是在mid左右两侧取值，这样显然更快。
int l, r, mid;
while (r - l >= 3) {
    mid = (l + r) >> 1;
    if (f(mid) > f(mid + 1)) l = mid + 1;
    else r = mid;
}
//为了避免边界错误，分到只剩3个数就枚举一遍。
int ans, tmp = INT_MAX;
for (int i = l; i <= r; i++) {
    if (f(i) < tmp) {
        ans = i;
        tmp = f(i);
    }
}
```

## [模拟退火](https://oi-wiki.org/misc/simulated-annealing/)

## 离线算法

### [莫队](https://oi-wiki.org/misc/mo-algo/)

### [整体二分](/2022/10/26/整体二分)

### [CDQ分治](/2022/10/26/CDQ分治)

## 搜索

### 暴力枚举

### DFS

注意边界，注意 `bool` 数组的标记， 不要重复搜索。

### BFS

注意边界，注意 `bool` 数组的标记， 不要重复搜索。

### 记忆化搜索

### [A*](https://oi-wiki.org//search/astar/) & [IDA*](https://oi-wiki.org//search/idastar/)

#### 记忆化

## [前缀和及二维前缀和](/2022/07/13/Prozor-题解)

```cpp
for (int i = 1; i <= n; i++) {
    sum[i] = sum[i - 1] + num[i];
}
//查找区间和：i...j = sum[j] - sum[i - 1];

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + num[i][j];
    }
}
//查找矩阵和：(x,y),(i,j) = sum[i][j] - sum[i][y - 1] - sum[x][j - 1] + sum[x - 1][y - 1];
```

## 差分
```cpp
for (int i = 1; i <= n; i++) {
    f[i] = num[i] - num[i - 1];
}
//区间更改：i...j + d -> f[i] += d; f[j + 1] -= d;
```

## 尺取法
拿草稿纸画一画。

## 数据结构
### 单调栈（含悬线法）

悬线法我不会啊。

单调栈一般维护当前节点往前找到的第一个小于/大于它的点，分别对应递增栈/递减栈。

```cpp
//递增栈
stack<int> s;
for (int i = 1; i <= n; i++) {
    while (!s.empty() && num[s.top()] >= num[i]) s.pop();
    min_left[i] = s.top();
    s.push(i);
}
//min_left中存储向左第一个小于它的节点的下标。
```

### 单调队列

单调队列一般维护当前节点往前找m个点的最大/小值，分别对应递增队列/递减队列。一般用 `deque` 实现。

```cpp
//递增队列
while (!q.empty()) q.pop_back();
num[0] = num[n + 1] = inf;
q.push_back(0);
for (int i = 1; i < k; i++) {
    while (!q.empty() && num[q.back()] >= num[i]) q.pop_back();
    q.push_back(i);
}
for (int i = k; i <= n; i++) {
    while (!q.empty() && num[q.back()] >= num[i]) q.pop_back();
    q.push_back(i);
    while (!q.empty() && q.front() < i - k + 1) q.pop_front();
    minium[i - k + 1] = num[q.front()];
}
```

### 优先队列（堆）

```cpp
bool operator < (your_own_node a, your_own_node b) {
    return a.v < b.v;
}
//重载运算符不能重载int这样的系统数据结构。

priority_queue<your_own_node> p_q;
//注意优先队列与运算符重载相反，这样写是大根堆。

template<class T>
class compare {
public:
    bool operator () (T a, T b) {
        return abs(a) < abs(b);
    }
};
priority_queue<int, vector<int>, compare<int> > p_q;
//用仿函数就可以支持系统类型，不过仍然相反，这样写是按绝对值的大根堆。
//less和greater其实也是这个原理。
```

## [数据结构](/2022/07/13/模板)

### [分块](/2022/07/13/分块——暴力美学)

## 动态规划

### [线性动规](/2022/07/13/NOIP2013-提高组-花匠-题解)

### [背包](/2022/07/13/弹珠-题解)

### [区间动规](https://oi-wiki.org/dp/interval/)

### [树型动规](https://oi-wiki.org/dp/tree/)

### [单调队列优化](/2022/10/27/单调队列优化DP)

### [状压DP](/2022/10/27/状压DP)

## 数学

### [数论基础](/2022/07/13/数论)

### [狄利克雷卷积](/2022/10/21/杜教筛) & [反演](/2022/10/24/反演)

### [狄利克雷前缀和](/2022/08/08/Dirichlet-前缀和)

### [逆元](https://oi-wiki.org/math/number-theory/inverse/)

### [质数](https://oi-wiki.org/math/number-theory/prime/) & [质因数分解](https://zhuanlan.zhihu.com/p/267884783)

## 树论

### [dfs 序](/2022/10/26/dfs序)

### [lca](https://oi-wiki.org/graph/lca/)

### [树链剖分](https://oi-wiki.org/graph/hld/)

### [树的重心 & 点分树](/2022/10/27/点分治)

## 图论

### 图的存储

```
std::vector<int> graph[maxn];
graph[u].emplace_back(v);
```

### 拓扑排序

对于有向无环图，每次选择入度为 0 的点，放入队列，然后删除他的所有出边。入队的顺序称为拓扑序，具有无后效性的特点。可以跑 dp 。

另： tarjan 缩点的顺序是逆拓扑序。

代码：

```cpp
// 咕一会儿
```

### [最短路算法](https://oi-wiki.org/graph/shortest-path/)

### [最小生成树](https://oi-wiki.org/graph/mst/)

### [匈牙利](/2022/10/26/匈牙利算法)

### [tarjan](/2022/10/27/tarjan)

### [2-SAT](/2022/10/26/2-SAT)

### [网络流](https://oi-wiki.org/graph/flow/max-flow/)

## 字符串

### [字符串 hash](https://oi-wiki.org/string/hash/)

### [KMP](/2022/10/27/KMP)

### [trie](https://oi-wiki.org/string/trie/)

## STL

### pair

### map

### set

### bitset

### stack

### queue

### deque

### priority_queue

### vector
