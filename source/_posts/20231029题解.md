---
title: 20231029题解
date: 2023-10-29 16:23:27
updateDate: 2023-10-29 16:23:27
tags:
categories:
- 信奥
- 题解
comments: true
top: 2
---

---
<!--more-->

## perm

记 $S = \frac{x + y}{\operatorname{gcd}(x, y)}$，打表出结论：

$$
f(x, y)=
    \begin{cases}
    \log_2 S &\log_2 S \in \mathbb{Z} \\
    0 & \text{otherwise.}
    \end{cases}
$$

所以我们可以枚举 $\operatorname{gcd}(x, y),x,S$，对于每一个 $x$ 寻找有哪些 $y$ 使得 $f(x, y) \ne 0$，我们把这些数记为一个序列 $p_i$。时间复杂度 $\mathcal{O}(n\log^2{n})$。

接下来考虑原题：记 $S(l, r)=\sum_{i=1}^{l}\sum_{j=1,j \ne i}^{r}f(i,j)$，则要求的结果就是 $\frac{1}{2}(S(r, r)-S(r, l-1)-S(l-1, r)+S(l-1, l-1))$。离线这些 $S$。这是一个类似于二维偏序的问题：维护一个树状数组，从小到大枚举 $i$，将树状数组的 $p_{ij}$ 位置加上 $f(a_i, a_{p_{ij}})$。这样，当 $i$ 枚举完时，$S(i, r)=\operatorname{query}(r),\operatorname{query}$ 是树状数组查询函数。$i$ 从 1 枚举到 $n$，所有的 $S$ 也自然被解决。

总时间复杂度大概 $\mathcal{O}(q \log n + n \log^3 n)$，不过后面一项完全跑不满。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 3e5 + 5, maxq = 1e6 + 5;
int n, a[maxn], q, b[maxn], ans[maxq], c[maxn];
vector<int> p[maxn];
struct node { int id, from; node() {} node(int id, int from): id(id), from(from) {}};
vector<node> qq[maxn];
void update(int pos, int x) {...}
int ask(int pos) {...}

int main() {
	freopen("perm.in", "r", stdin);
	freopen("perm.out", "w", stdout);
	read(n);
	for (int i = 1; i <= n; i++) read(a[i]), b[a[i]] = i;
	for (int d = 1; d <= n; d++) {
		for (int i = d; i <= n; i += d) {
			for (int j = 2; j * d - i <= n; j <<= 1) {
				if (j * d <= i) continue;
				if (__gcd(i, j * d - i) != d) continue;
				if (j * d == i * 2) continue;
				p[b[i]].emplace_back(b[j * d - i]);
			}
		}
	}
	read(q);
	for (int i = 1; i <= q; i++) {
		int l, r; read(l); read(r);
		qq[l - 1].emplace_back(l - 1, i);
		qq[l - 1].emplace_back(r, -i);
		qq[r].emplace_back(l - 1, -i);
		qq[r].emplace_back(r, i);
	}
	for (int i = 1; i <= n; i++) {
		for (int j : p[i]) update(j, __builtin_ctz((a[i] + a[j]) / __gcd(a[i], a[j])));
		for (auto x : qq[i]) {
			if (x.from > 0) ans[x.from] += ask(x.id);
			else ans[-x.from] -= ask(x.id);
		}
	}
	for (int i = 1; i <= q; i++) printf("%d\n", ans[i] / 2);
	return 0;
}
```